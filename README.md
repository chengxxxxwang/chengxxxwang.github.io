## Welcome to My GitHub Pages
-----------------------
> ``https://chengxxxxwang.github.io/chengxxxwang.github.io/``


# Learn-Efficient-Objective-C

## 1. Objective-C 是一门动态语言
> ``Objective-C``编写的程序不能直接编译成可执行机器语言(二进制编码),而是在程序运行时(``Runtime``)把程序转译成可执行的机器语言.
	``Objective-C``会尽可能的将编译和链接时要做的事情推迟到运行时来做
1. ``Objective-C`` 是动态语言,C++,Swift是静态语言
2. 静态语言执行效率和安全环境要比动态语言高,但其简便性没有动态语言那么高
3. 运行时(Runtime)环境可处理弱类型,函数存在检查工作,会检测注册表里是否存在对应的函数,类型是否正确,最后确定正确的函数地址,在进行寄存器状态,压栈,函数调用等实际操作,确保了``Objective-C``的类活性

## 2. 在头文件中尽量减少其他头文件的引用
1. 在头文件(.h)中,关键字``@class``只是为了在头文件中引用这个类,把这个类作为一个类型来引用,这就要求引用的头文件(.h)名与类名一致
2. 在头文件(.h)中使用``@class``,在源文件(.m)中使用``#import``不但可以减少不必要的编译时间,降低类之间的耦合度,而且还可以避免产生循环引用
3. 在设计类时,尽量多采用协议,避免``#import``过多,引进不必要的部分
4. 如果头文件(.h)中有多个类的定义,尽量采用模块方式,只针对性引进所需的类

## 3.尽量使用 ``const``,``enum``来替换 预处理命令 ``#define``
> ``#define``定义了一个宏,在编译开始之前就会被替换
> ``const`` 只是对变量进行修饰,当试图去修改变量时,编译器就会报错(在一些场景下只能使用``#define``,而不能使用``const``,理论上,``const``不仅在运行时需要占用空间,而且还需要一个内存的引用,``#define``在理论上更为高效,但是在现在的编译器上开始变得无关紧要了. ``const`` 在编译和调试的时候会比``#define``要友好.对于整形类型来说,我们通常建议使用``enum``)

1. 尽量避免使用``#define``预处理命令,``#define``预处理命令不包含任何类型的的信息,仅仅是在编译前进行替换操作.它们在重复定义时不会发出警报(最新的xcode 版本中 重复定义宏会有重复提示),容易在整个程序中产生不一致的值
2. 在源文件 .m 中定义的``static const``类型常量,因为无需全局引用,所以他们的名字不需要包含命名空间
3. 在头文件 .h 中定义的全局引用常量,需要关联定义在源文件 .m中的部分.因为需要全局引用,所以它们的名字需要包含命名空间,通常是它的类名作为前缀
4. 尽量使用 ``NS_ENUM`` 和 ``NS_OPTION``宏来实现枚举

## 4. 优先使用对象的字面量语法而非等效方法
### 数字写法(`NSNumber`) 

```
//:简化前
NSNumber *val ;
val = [NSNumber numberWithInt:123456];
val = [NSNumber numberWithFloat:1234.56f];
val = [NSNumber numberWithDouble:1234.56];
val = [NSNumber numberWithBool:YES];

//:化简后
NSNumber *val ;

val = @123456;
val = @1234.56f;
val = @1234.56;
val = @YES;
```

### 数组(`NSArray`)

```
NSArray *arr;

arr = @[];//空数组
arr = @[a];//存有对象a的数组
arr = @[a,b,c];//存有多个对象的数组
```

### 字典(`NSDictionary`)

```
NSDictionary *dict;

dict = @{}; //空字典
dict = @{k1:v1}; //包含一个键值对的字典
dict = @{k1:v1,k2:v2,k3:v3};//包含多个键值对的字典
```

### 下标法与容器类

容器类可以通过下标的方式存取数组和字典的数据

```
//:数组
NSArray *array = @[a,b,c];
//:可以这样写 通过下标获取数组对象替换原有的写法 [array objectAtIndex:i] 

id obj = array[i]
//:也可以直接为数组对象赋值,替换原有的方法 [array replaceObjectAtIndex:i withObject:obj];
array[i] = obj

同理适用于 字典

NSDictionary *dict = @{k1:v1,k2:v2,k3:v3};

id obj = dict[k2]

dict[k2] = obj
```

### 容器类数据结构简化的限制
1. 容器类为不可变,如果需要生成可变容器,可以传递``mutableCopy``消息 比如 

```
NSMutableArray *muArr = [@[
	@"Monday",
	@"Tuesday",
	"Wednesday",
	@"Thursday",
	@"Friday",
	@"Saturday",
	@"Sunday"] mutableCopy];

```
2. 不能对常量数组进行直接赋值(在类方法``+ (void)initialize中进行赋值``)

> 数组``NSArray``和字典``NSDictionary``等类,由于能像'容器'一样容纳东西,所以,也把这些具有容器属性的类称为**容器类**

1. 尽量使用对象字面量语法来创建字符串,数字,数组和字典等,使用它比使用常规对象的创建方法更为简洁,同时可以避免一些常见陷阱
2. 对象字面量语法特性是完全向下兼容的,使用心得特性编写出的代码,通过编译器后形成的二进制程序可以运行在之前发布的任何OS系统中
3. 在数字和字典中,要使用关键字和索引做下标来获取数据
4. 使用对象的字面量语法时,容器类不能为nil,否则抛出异常

## 5. 处理隐藏的返回类型,优先选择实例类型``instancetype``而非 ``id``

1. ``instancetype`` 仅仅用来作为``Objective-C``方法的返回值类型
2. 使用``instancetype``可以避免隐式转换``id``而造的欺骗性编译无法通过的现象,防止程序正式运行时出现崩溃的现象,可以大大的改善``Objective-C``代码的类型安全
3. 在某一特定区域,``instancetype``可以替代`id`,并非所有的区域都可以替代`id`

## 6.尽量使用模块方式与多类建立复合关系

1. `#import` 和 `#include` ,其根本就是简单的复制,粘贴,将目标.h文件中的内容一字不落的复制到当前文件中,后者可以避免多次的重复引用
2. 以预编译头文件的方式,虽然可缩短编译时间,但其维护棘手,不利于广泛应用
3. 模块功能,其应用不仅仅表现于编译的速度加快,同时在链接框架等方面也非常好用
4. 启动模块功能后编译器会隐式地把所有的`#import`都转换成`@import`

## 7.明解`Objective-C++`中的有所为有所不为
> Xcode中需要源文件以`.mm`为扩展名,这样才能启动编译器`Objective-C++`扩展

1. C++ 和 Objective-C 在定义结构上一样,但是后者的集成是封闭的
2. Objective-C 接口中定义的C++类是全局范围的,而不是Objective-C累的内嵌类
3. C++ 和Objective-C的对象模型不能直接兼容.与Objective-C不同的是,C++的对象是静态类型的,有运行时系统多态是特殊情况
4. C++ 和Objective-C 有词汇歧义和冲突
5. C++ 和 Objective-C两者功能上有限制.Objective-C++ 没有为Objective-C类增加C++的功能,有没有为C++添加Objective-C的功能

## 8. C语言与Objective-C语言的关系是充分而非必要条件

>1. C语言中的每个标准变量类型在Objective-C中都可以使用
>2. C语言中的标准运算符在Objective-C中可用
>3. 可用标量来表示Objective-C的属性 比如``@property double currentValue;``
>4. 通过点语法访问值时,可以在属性中使用C操作符
>5. 在Objective-C 中定义了新的基本数据类型
>6. C语言中的数据结构在Objective-C中可以保持其基本值
>7. Objective-C值对象比C语言类型变量具有封装常用操作的优势


### tips
1. C语言的基本语法子啊Objective-C语言中是可用的
2. 与C语言相比,Objective-C语言定义了新的基本数据类型,比如BOOL,Block等
3. Objective-C值对象比C类型变量具有封装常用操作的优势,但是在数据运算时,使用C类型标量更为简洁


## 9.警惕空指针和野指针

### 1. 空指针和野指针
>  没有存储任何内存地址的指针就称为**空指针**(NULL指针).空指针,就是被赋值为0的指针,在没有被具体初始化之前,其值为0,意思是:一个指针变量分配一个``NULL``值的情况下,没有确切的地址被分配


```
//空指针
Person *p1 = NULL;
Person *p2 = nil;

```

~~NULL指针,是一个常数与几个标准库中定义的一个零值~~

**野指针**不是NULL指针,而是指向"垃圾"内存(不可用内存)的指针,野指针非常危险

### 2. 空指针和野指针的区别和防御

在Xcode中使用内存管理调试的"僵尸对象"(``Zombie Objects``)帮助我们检测垃圾内存

```
//自定义一个Person 类,然后调用

Person *p = [[Person alloc] init];
[p setAge:10];
[p release];
[p setAge:20];

```
运行,发现程序报错在 ``==> [p setAge:20];``
在p 执行释放方法之后 Person 对象被销毁了, ``*p`` 指向的内存变成了"垃圾内存",但是 p 仍指向这块内存,此时 p变成了 **野指针**

如果对程序做一下修改,就不会报错了
```
//自定义一个Person 类,然后调用

Person *p = [[Person alloc] init];
[p setAge:10];
[p release];

p = nil;
[p setAge:20];

```

``p = nil``执行之后,p 称为 **空指针**,不再指向任何内存,继续执行 ``setAge:``时,由于 p此时成了空指针,没有指向任何对象,则无法发送 ``setAge: ``消息,就不会对程序造成任何影响了


### tips 

1. 空指针(NULL指针),是指没有存储任何内存地址的指针. 野指针,是执行"垃圾内存"(不可用内存)的指针.
2. **利用野指针发消息是十分危险的,会报错.也就是说,如果一个对象已经被回收了,就不要在去对他进行操作,不要尝试给他发送任何消息**
3. 利用空指针发消息是没有任何问题的,也就是说代码是没有错误的


## 10. 在64位环境下尽可能利用标记指针

>Mac OS X 10.6 中开始支持64位,随之iPhone5s开始采用 Arm64架构,在Mac OS X 10.7 和 iOS 7 64位环境引入**标记指针**(Tagged) ... 到现在,iOS系统的不断升级(iOS 10.3.2 之后版本将不再支持 32位环境),64位化(苹果下的一盘大棋落子收官)

### Tagged 指针详解及应用(TODO)

### tips 
1. 利用``Tagged``指针,可以子啊指针地址中保存活附加更多的信息
2. 利用``Tagged``指针处理NSNumber,直接可以把实际的值保存到指针中,而无需再去访问堆中的数据,可以提法哦内存访问的速度和整体运算时间
3. 在 32位和64位的环境下,``isa``指针会产生不同的变化.在64位下,标记``Tagged``指针可以加快``isa``指针的处理效率

## 11. 兼容32位和64位环境下代码编写事项

### 1.不要把长整型数据赋予整型

### 2.善用``NSInteger``来处理32位和64位之间的转换

### 3.创建数据结构要注意固定大小和对齐

使用 pragma 控制对齐
下面的结构是被迫使用 32位对齐规则的
```
#pragma pack(4)

struct bar{
	int32_t foo0;
	int32_t foo1;
	int32_t foo2;
	int64_t bar;
};
#pragma options align=reset

```

### 4.选择一种紧凑的数据表示形式

### tips
1. 不要将长整型赋予整型
2. 利用``NSInteger``来处理32位和64位之间的转换
3. 创建数据结构要注意固定大小和对齐


## 12 .清楚常量字符串和一般字符串的区别

1. 由于编译器的优化,相同的长两字符串的地址是完全相同的
2. 如果使用常量字符串来初始化一个字符串,那么这个字符串也将是相同的常量
3. 对常量字符串永远不要 ``release``


## 13. 在访问集合时哟啊有限考虑使用快速枚举
**快速枚举**

```
//for...in表达式
for(Type newVariable in expression){ statements }
//或者
Type existingItem;
for (existingItem in expression) { statements }

```


### tips
1. 尽可能多的使用快速枚举
2. 和直接使用``NSEnumerator``相比,使用快速枚举可以更有效率,表达式更简洁
3. 使用快速枚举,枚举更安全,因为枚举会监控枚举对象的变化,如果在枚举的过程中枚举对象发生变化,会抛出一个异常
4. 多个枚举可以同时进行,因为在循环过程中被循环对象是禁止修改的.另外,同其他循环一样,可以使用`break`来停止循环或者使用`continue`来略过当次循环进行到下一元素



## 14.有序对象适宜存于数组,而无序对象适宜存于集合

###tips
1. 数组可以维持持续性,所以可以存储有序的对象,蛋每一项必须是`Objective-C`对象,集合(`set`)不维持秩序,所以适宜存储无序对象
2. 同一数组 可以保存不同的对象,但不能存储`float`,`int`,`double`等基本数据类型和`nil`,否则存储的基本类型都会被置0,不能存储nil,是因为,数组必须使用nil结尾
3. 快速枚举是访问数组中的对象的一种比较快的方法
4. 使用`NSArray`和`NSDictionary`类可以直接将其内容写入磁盘进行持久化



## 15. 存在公共键时,字典是在对象之间传递信息的最佳方式

### tips
1. 字典不仅可以作为无序对象的结合,还可以作为有序对象的集合
2. 字典可作为有序对象的集合,主要依赖于键值可采用有序
3. 存在公共键时,字典是在对象之间传递各种信息的最佳方式



## 16.明智而谨慎的使用BOOL类型
### tips
1. 整型转为BOOL型,使用三元(`Ternery`)操作符,以保证返回`YES`或`NO`
2. 整型转为`BOOL`型的时候要避免直接和`YES`作比较
3. `BOOL`值进行逻辑运算(`&& , || ,! `)不但有效,而且还可以确保返回值安全的转为`BOOL`型,无须三元操作符



## 17. 理解内存和`Objective-C`内存管理规则

### 1. 内存是程序赖以生存之本

```
	带宽 = 总线宽度 * 总线频率 * 一个时钟周期内交换的数据包个数
```

### 2.`Objective-C`内存的管理规则

**谁使用谁负责释放**

### tips
1. 内存是内存控制器与`CPU`之间的桥梁,内存相当于*仓库*
2. `Objective-C`的内存管理是基于对象的`所有权`上,任何对象都会被一个或者多个使用者引用,只要对象还有一个使用者,该对象就应该继续存在,,如果一个对象没有使用者了,那么系统将会自动销毁它
3. 对象的所有权策略是基于引用计数实现的,每一个对象都有一个``retaincount``变量,对象创建之后,``retaincount``是1,``retain``之后,
``retain count + 1``;`release`之后,``retain count - 1``,对象``retain count = 0``时,对象销毁


## 18. 内存管理讲究: `好借好还,再借不难`

### tips

1. 在`Objective-C`中,释放对象应该优先使用`release`而非`autorelease`,但在不适合立即回收对象的情况下,应该首先使用`autorelease`
2. 当返回一个新的新创建的(拥有的)对象时,应该使用`autorelease`而不是用`release`来释放所有权
3. 对于拥有``alloc``返回的对象而言,失去释放所有权之前,应该先失去对该对象的引用

## 19. 区别开 `alloc`,`init`,`retain`,`release`和`dealloc`的差异

### 1.`alloc`是创建变量,`dealloc`是释放变量,``retain``是计数+1,``release``是计数-1
### 2.分配过程(`alloc`和`init`)不仅进行对象的内存分配,还要对它的`isa`实例变量和保持数初始化
### 3.对象赋值时,尽量采用`autorelease`而不是`retain`模式


## 20. 优先选用存取方法来简化内存管理

### tips
1. 使用存取方法管理内存,可大大降低管理方面的问题
2. 在代码中,管理实例变量尽可能避免全部使用`retain`和`release`,降低错误的发生概率
3. 在`init`方法和`dealloc`两处地方,不要使用存取方法来设置实例变量
4. 实现方法的重置,有两种选择,一种是使用简便构造函数创建一个新的对象,因此没有必要发送任何`retain`和`release`消息;另一种是使用`alloc`
创建实例,要相应的使用`release`.(**两种方法都使用了类的`set`存取方法**)


## 21. 对象销毁或者被移除一定要考虑所有权的释放

### tips
1. 从集合中移除对象,集合要释放别移除对象的所有权
2. 防止出现父对象被释放,而子对象没有释放
3. 释放对象前,要确保其他对象对对该对象的所有权已经释放
4. 在`Objective-C`中,是否负责对象的释放,需要看如何获取对象,即要看对象的所有权策略

