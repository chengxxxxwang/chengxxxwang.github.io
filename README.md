## Welcome to My GitHub Pages
-----------------------
> ``https://chengxxxxwang.github.io/chengxxxwang.github.io/``


# Learn-Efficient-Objective-C

## 1. Objective-C 是一门动态语言
> ``Objective-C``编写的程序不能直接编译成可执行机器语言(二进制编码),而是在程序运行时(``Runtime``)把程序转译成可执行的机器语言.
	``Objective-C``会尽可能的将编译和链接时要做的事情推迟到运行时来做
1. ``Objective-C`` 是动态语言,C++,Swift是静态语言
2. 静态语言执行效率和安全环境要比动态语言高,但其简便性没有动态语言那么高
3. 运行时(Runtime)环境可处理弱类型,函数存在检查工作,会检测注册表里是否存在对应的函数,类型是否正确,最后确定正确的函数地址,在进行寄存器状态,压栈,函数调用等实际操作,确保了``Objective-C``的类活性

## 2. 在头文件中尽量减少其他头文件的引用
1. 在头文件(.h)中,关键字``@class``只是为了在头文件中引用这个类,把这个类作为一个类型来引用,这就要求引用的头文件(.h)名与类名一致
2. 在头文件(.h)中使用``@class``,在源文件(.m)中使用``#import``不但可以减少不必要的编译时间,降低类之间的耦合度,而且还可以避免产生循环引用
3. 在设计类时,尽量多采用协议,避免``#import``过多,引进不必要的部分
4. 如果头文件(.h)中有多个类的定义,尽量采用模块方式,只针对性引进所需的类

## 3.尽量使用 ``const``,``enum``来替换 预处理命令 ``#define``
> ``#define``定义了一个宏,在编译开始之前就会被替换
> ``const`` 只是对变量进行修饰,当试图去修改变量时,编译器就会报错(在一些场景下只能使用``#define``,而不能使用``const``,理论上,``const``不仅在运行时需要占用空间,而且还需要一个内存的引用,``#define``在理论上更为高效,但是在现在的编译器上开始变得无关紧要了. ``const`` 在编译和调试的时候会比``#define``要友好.对于整形类型来说,我们通常建议使用``enum``)

1. 尽量避免使用``#define``预处理命令,``#define``预处理命令不包含任何类型的的信息,仅仅是在编译前进行替换操作.它们在重复定义时不会发出警报(最新的xcode 版本中 重复定义宏会有重复提示),容易在整个程序中产生不一致的值
2. 在源文件 .m 中定义的``static const``类型常量,因为无需全局引用,所以他们的名字不需要包含命名空间
3. 在头文件 .h 中定义的全局引用常量,需要关联定义在源文件 .m中的部分.因为需要全局引用,所以它们的名字需要包含命名空间,通常是它的类名作为前缀
4. 尽量使用 ``NS_ENUM`` 和 ``NS_OPTION``宏来实现枚举

## 4. 优先使用对象的字面量语法而非等效方法
### 数字写法(`NSNumber`) 

```
//:简化前
NSNumber *val ;
val = [NSNumber numberWithInt:123456];
val = [NSNumber numberWithFloat:1234.56f];
val = [NSNumber numberWithDouble:1234.56];
val = [NSNumber numberWithBool:YES];

//:化简后
NSNumber *val ;

val = @123456;
val = @1234.56f;
val = @1234.56;
val = @YES;
```

### 数组(`NSArray`)

```
NSArray *arr;

arr = @[];//空数组
arr = @[a];//存有对象a的数组
arr = @[a,b,c];//存有多个对象的数组
```

### 字典(`NSDictionary`)

```
NSDictionary *dict;

dict = @{}; //空字典
dict = @{k1:v1}; //包含一个键值对的字典
dict = @{k1:v1,k2:v2,k3:v3};//包含多个键值对的字典
```

### 下标法与容器类

容器类可以通过下标的方式存取数组和字典的数据

```
//:数组
NSArray *array = @[a,b,c];
//:可以这样写 通过下标获取数组对象替换原有的写法 [array objectAtIndex:i] 

id obj = array[i]
//:也可以直接为数组对象赋值,替换原有的方法 [array replaceObjectAtIndex:i withObject:obj];
array[i] = obj

同理适用于 字典

NSDictionary *dict = @{k1:v1,k2:v2,k3:v3};

id obj = dict[k2]

dict[k2] = obj
```

### 容器类数据结构简化的限制
1. 容器类为不可变,如果需要生成可变容器,可以传递``mutableCopy``消息 比如 

```
NSMutableArray *muArr = [@[
	@"Monday",
	@"Tuesday",
	"Wednesday",
	@"Thursday",
	@"Friday",
	@"Saturday",
	@"Sunday"] mutableCopy];

```
2. 不能对常量数组进行直接赋值(在类方法``+ (void)initialize中进行赋值``)

> 数组``NSArray``和字典``NSDictionary``等类,由于能像'容器'一样容纳东西,所以,也把这些具有容器属性的类称为**容器类**

1. 尽量使用对象字面量语法来创建字符串,数字,数组和字典等,使用它比使用常规对象的创建方法更为简洁,同时可以避免一些常见陷阱
2. 对象字面量语法特性是完全向下兼容的,使用心得特性编写出的代码,通过编译器后形成的二进制程序可以运行在之前发布的任何OS系统中
3. 在数字和字典中,要使用关键字和索引做下标来获取数据
4. 使用对象的字面量语法时,容器类不能为nil,否则抛出异常

## 5. 处理隐藏的返回类型,优先选择实例类型``instancetype``而非 ``id``

1. ``instancetype`` 仅仅用来作为``Objective-C``方法的返回值类型
2. 使用``instancetype``可以避免隐式转换``id``而造的欺骗性编译无法通过的现象,防止程序正式运行时出现崩溃的现象,可以大大的改善``Objective-C``代码的类型安全
3. 在某一特定区域,``instancetype``可以替代`id`,并非所有的区域都可以替代`id`

## 6.尽量使用模块方式与多类建立复合关系

1. `#import` 和 `#include` ,其根本就是简单的复制,粘贴,将目标.h文件中的内容一字不落的复制到当前文件中,后者可以避免多次的重复引用
2. 以预编译头文件的方式,虽然可缩短编译时间,但其维护棘手,不利于广泛应用
3. 模块功能,其应用不仅仅表现于编译的速度加快,同时在链接框架等方面也非常好用
4. 启动模块功能后编译器会隐式地把所有的`#import`都转换成`@import`

## 7.明解`Objective-C++`中的有所为有所不为
> Xcode中需要源文件以`.mm`为扩展名,这样才能启动编译器`Objective-C++`扩展

1. C++ 和 Objective-C 在定义结构上一样,但是后者的集成是封闭的
2. Objective-C 接口中定义的C++类是全局范围的,而不是Objective-C累的内嵌类
3. C++ 和Objective-C的对象模型不能直接兼容.与Objective-C不同的是,C++的对象是静态类型的,有运行时系统多态是特殊情况
4. C++ 和Objective-C 有词汇歧义和冲突
5. C++ 和 Objective-C两者功能上有限制.Objective-C++ 没有为Objective-C类增加C++的功能,有没有为C++添加Objective-C的功能

## 8. C语言与Objective-C语言的关系是充分而非必要条件

>1. C语言中的每个标准变量类型在Objective-C中都可以使用
>2. C语言中的标准运算符在Objective-C中可用
>3. 可用标量来表示Objective-C的属性 比如``@property double currentValue;``
>4. 通过点语法访问值时,可以在属性中使用C操作符
>5. 在Objective-C 中定义了新的基本数据类型
>6. C语言中的数据结构在Objective-C中可以保持其基本值
>7. Objective-C值对象比C语言类型变量具有封装常用操作的优势


### tips
1. C语言的基本语法子啊Objective-C语言中是可用的
2. 与C语言相比,Objective-C语言定义了新的基本数据类型,比如BOOL,Block等
3. Objective-C值对象比C类型变量具有封装常用操作的优势,但是在数据运算时,使用C类型标量更为简洁


## 9.警惕空指针和野指针

### 1. 空指针和野指针
>  没有存储任何内存地址的指针就称为**空指针**(NULL指针).空指针,就是被赋值为0的指针,在没有被具体初始化之前,其值为0,意思是:一个指针变量分配一个``NULL``值的情况下,没有确切的地址被分配


```
//空指针
Person *p1 = NULL;
Person *p2 = nil;

```

~~NULL指针,是一个常数与几个标准库中定义的一个零值~~

**野指针**不是NULL指针,而是指向"垃圾"内存(不可用内存)的指针,野指针非常危险

### 2. 空指针和野指针的区别和防御

在Xcode中使用内存管理调试的"僵尸对象"(``Zombie Objects``)帮助我们检测垃圾内存

```
//自定义一个Person 类,然后调用

Person *p = [[Person alloc] init];
[p setAge:10];
[p release];
[p setAge:20];

```
运行,发现程序报错在 ``==> [p setAge:20];``
在p 执行释放方法之后 Person 对象被销毁了, ``*p`` 指向的内存变成了"垃圾内存",但是 p 仍指向这块内存,此时 p变成了 **野指针**

如果对程序做一下修改,就不会报错了
```
//自定义一个Person 类,然后调用

Person *p = [[Person alloc] init];
[p setAge:10];
[p release];

p = nil;
[p setAge:20];

```

``p = nil``执行之后,p 称为 **空指针**,不再指向任何内存,继续执行 ``setAge:``时,由于 p此时成了空指针,没有指向任何对象,则无法发送 ``setAge: ``消息,就不会对程序造成任何影响了


### tips 

1. 空指针(NULL指针),是指没有存储任何内存地址的指针. 野指针,是执行"垃圾内存"(不可用内存)的指针.
2. **利用野指针发消息是十分危险的,会报错.也就是说,如果一个对象已经被回收了,就不要在去对他进行操作,不要尝试给他发送任何消息**
3. 利用空指针发消息是没有任何问题的,也就是说代码是没有错误的


## 10. 在64位环境下尽可能利用标记指针

>Mac OS X 10.6 中开始支持64位,随之iPhone5s开始采用 Arm64架构,在Mac OS X 10.7 和 iOS 7 64位环境引入**标记指针**(Tagged) ... 到现在,iOS系统的不断升级(iOS 10.3.2 之后版本将不再支持 32位环境),64位化(苹果下的一盘大棋落子收官)

### Tagged 指针详解及应用(TODO)

### tips 
1. 利用``Tagged``指针,可以子啊指针地址中保存活附加更多的信息
2. 利用``Tagged``指针处理NSNumber,直接可以把实际的值保存到指针中,而无需再去访问堆中的数据,可以提法哦内存访问的速度和整体运算时间
3. 在 32位和64位的环境下,``isa``指针会产生不同的变化.在64位下,标记``Tagged``指针可以加快``isa``指针的处理效率

## 11. 兼容32位和64位环境下代码编写事项

### 1.不要把长整型数据赋予整型

### 2.善用``NSInteger``来处理32位和64位之间的转换

### 3.创建数据结构要注意固定大小和对齐

使用 pragma 控制对齐
下面的结构是被迫使用 32位对齐规则的
```
#pragma pack(4)

struct bar{
	int32_t foo0;
	int32_t foo1;
	int32_t foo2;
	int64_t bar;
};
#pragma options align=reset

```

### 4.选择一种紧凑的数据表示形式

### tips
1. 不要将长整型赋予整型
2. 利用``NSInteger``来处理32位和64位之间的转换
3. 创建数据结构要注意固定大小和对齐


## 12 .清楚常量字符串和一般字符串的区别

1. 由于编译器的优化,相同的长两字符串的地址是完全相同的
2. 如果使用常量字符串来初始化一个字符串,那么这个字符串也将是相同的常量
3. 对常量字符串永远不要 ``release``


## 13. 在访问集合时哟啊有限考虑使用快速枚举
**快速枚举**

```
//for...in表达式
for(Type newVariable in expression){ statements }
//或者
Type existingItem;
for (existingItem in expression) { statements }

```


### tips
1. 尽可能多的使用快速枚举
2. 和直接使用``NSEnumerator``相比,使用快速枚举可以更有效率,表达式更简洁
3. 使用快速枚举,枚举更安全,因为枚举会监控枚举对象的变化,如果在枚举的过程中枚举对象发生变化,会抛出一个异常
4. 多个枚举可以同时进行,因为在循环过程中被循环对象是禁止修改的.另外,同其他循环一样,可以使用`break`来停止循环或者使用`continue`来略过当次循环进行到下一元素



## 14.有序对象适宜存于数组,而无序对象适宜存于集合

### tips
1. 数组可以维持持续性,所以可以存储有序的对象,蛋每一项必须是`Objective-C`对象,集合(`set`)不维持秩序,所以适宜存储无序对象
2. 同一数组 可以保存不同的对象,但不能存储`float`,`int`,`double`等基本数据类型和`nil`,否则存储的基本类型都会被置0,不能存储nil,是因为,数组必须使用nil结尾
3. 快速枚举是访问数组中的对象的一种比较快的方法
4. 使用`NSArray`和`NSDictionary`类可以直接将其内容写入磁盘进行持久化



## 15. 存在公共键时,字典是在对象之间传递信息的最佳方式

### tips
1. 字典不仅可以作为无序对象的结合,还可以作为有序对象的集合
2. 字典可作为有序对象的集合,主要依赖于键值可采用有序
3. 存在公共键时,字典是在对象之间传递各种信息的最佳方式



## 16.明智而谨慎的使用BOOL类型
### tips
1. 整型转为BOOL型,使用三元(`Ternery`)操作符,以保证返回`YES`或`NO`
2. 整型转为`BOOL`型的时候要避免直接和`YES`作比较
3. `BOOL`值进行逻辑运算(`&& , || ,! `)不但有效,而且还可以确保返回值安全的转为`BOOL`型,无须三元操作符



## 17. 理解内存和`Objective-C`内存管理规则

### 1. 内存是程序赖以生存之本

```
	带宽 = 总线宽度 * 总线频率 * 一个时钟周期内交换的数据包个数
```

### 2.`Objective-C`内存的管理规则

**谁使用谁负责释放**

### tips
1. 内存是内存控制器与`CPU`之间的桥梁,内存相当于*仓库*
2. `Objective-C`的内存管理是基于对象的`所有权`上,任何对象都会被一个或者多个使用者引用,只要对象还有一个使用者,该对象就应该继续存在,,如果一个对象没有使用者了,那么系统将会自动销毁它
3. 对象的所有权策略是基于引用计数实现的,每一个对象都有一个``retaincount``变量,对象创建之后,``retaincount``是1,``retain``之后,
``retain count + 1``;`release`之后,``retain count - 1``,对象``retain count = 0``时,对象销毁


## 18. 内存管理讲究: `好借好还,再借不难`

### tips

1. 在`Objective-C`中,释放对象应该优先使用`release`而非`autorelease`,但在不适合立即回收对象的情况下,应该首先使用`autorelease`
2. 当返回一个新的新创建的(拥有的)对象时,应该使用`autorelease`而不是用`release`来释放所有权
3. 对于拥有``alloc``返回的对象而言,失去释放所有权之前,应该先失去对该对象的引用

## 19. 区别开 `alloc`,`init`,`retain`,`release`和`dealloc`的差异

### 1.`alloc`是创建变量,`dealloc`是释放变量,``retain``是计数+1,``release``是计数-1
### 2.分配过程(`alloc`和`init`)不仅进行对象的内存分配,还要对它的`isa`实例变量和保持数初始化
### 3.对象赋值时,尽量采用`autorelease`而不是`retain`模式


## 20. 优先选用存取方法来简化内存管理

### tips
1. 使用存取方法管理内存,可大大降低管理方面的问题
2. 在代码中,管理实例变量尽可能避免全部使用`retain`和`release`,降低错误的发生概率
3. 在`init`方法和`dealloc`两处地方,不要使用存取方法来设置实例变量
4. 实现方法的重置,有两种选择,一种是使用简便构造函数创建一个新的对象,因此没有必要发送任何`retain`和`release`消息;另一种是使用`alloc`
创建实例,要相应的使用`release`.(**两种方法都使用了类的`set`存取方法**)


## 21. 对象销毁或者被移除一定要考虑所有权的释放

### tips
1. 从集合中移除对象,集合要释放别移除对象的所有权
2. 防止出现父对象被释放,而子对象没有释放
3. 释放对象前,要确保其他对象对对该对象的所有权已经释放
4. 在`Objective-C`中,是否负责对象的释放,需要看如何获取对象,即要看对象的所有权策略


## 22.明智而审慎的使用 `dealloc`

### tips
1. 任何时候,都不要直接调用另一个对象的`dealloc`
2. 不许在 `dealloc`的最后一行调用父类的`dealloc`
3. 不要尝试管理系统资源,应用程序终止时,对象的`dealloc`可能不用被调用,应为程序的内存是自动清除退出,让操作系统清理资源比用调用所有的内存管理方法都更有效率

## 23. 编写代码要遵守 `cocoa API` 约定

### tips 
1. 在API命名上,清除是第一原则,而非简洁,切记避免模棱两可的命名
2. 在对函数活方法的命名上,务必使用**动词**,突显函数和方法的**动性**
3. 在API名称上不要使用缩写,除非是众所周知的缩写比如`HTML`,`TIFF`等
4. 在对类名和与类相关的符号命名(如函数和`typedef`定义形式的类型)时,务必使用前缀

## 24. 洞悉实例变量

```
@private 变量只限于声明它的类访问
@protected 变量可以被声明它的类及继承改类的类使用,所有没有明确指定访问范围的变量默认为@protected
@public 变量可以在任何位置访问
@package 类似于java中的包的概念,可以把不啊不夸被灌得访问范围控制在一个范围内,如一个framework
```


### tips
1. 实例变量的命名规则是使用小写字符串,不包含标点符号和特殊字符.如果变量名包含多个词,就直接把这些词连起来,而且第二个及之后的首字母大写
2. 只加入一些绝对必要的实例变量,否则容易造成大开销.在可能的情况下,尽量从有限的实例变量中计算出一个关键值,而不是增加新的实例变量
3. 永远不要将变量设置为`@public`,因为这违反了封装的原则
4. 确保类的基本属性对应的实例变量有存取方法


## 25. 透彻了解属性

### tips
1. 属性的动态性定义,需要关键字`@dynamic`.属性动态性是相对于`@synthesis`来说的,不是由编译器自动生成的`setter`或`getter`,而是运行时动态添加的`setter`和`getter`
2. 属性采用动态性,与采用静态性相比,可以简化代码的编写,便于代码的管理
3. 默认情况下,可写属性的使用的实例变量称为`_propertyName`.如果想要使用的实例变量不同名,需要在实现中指示编译器合成变量
4. 利用类扩展可实现对属性的**篡改**


## 26.存取方法是良好的类接口必要组成部分

### tips
1. 存取方法是通向对象属性的一道门槛,负责提供对象属性的访问通道,并强制对对象实例数据进行封装,防止实力数据被破坏
2. 方法的返回的对象,需要保证对象在该作用域被不被释放或者修改
3. 调用对象从某个方法(如存取方法)接受对象时,不应该对其进行释放,除非它先前进行`显式`的保持(或复制)

## 27.类公共领域的方法都是虚方法

### notes
1. 在`Objective-C`中所有的方法都是虚方法,
2. 实现虚方法依赖正式协议来实现
3. 协议并不是真正的类,它只能声明方法,不能添加数据
4. 非正式协议并不是正式的协议,它对代码没有约束力


## 28. 初始化还是解码取决于是否支持归档和解档

### notes
1. 类的对象支持归档和反归档(解档),该类必须遵守`NSCoding`协议,必须实现对对象进行编码(`encodeWithCoder:`)和解码(`initWIthCoder`)方法
2. 类的初始化方法和`initWithCoder`方法在角色上的并行性存在例外


## 29. 利用键-值机制访问累的私有成员变量和方法

### tips
1. 在`Objective-C`,类的成员变量或方法是没有绝对私有的,可以借助"编译运行时"机制,即`瞎子摸黑`机制来实现对它的访问
2. 在KVC和KVO在定制子类的设计时特别重要
3. KVC,KVO和KVB都支持遍历
4. KVC主要通过``isa``指针来实现其内部查找定位,KVO其设计基于设计模式中的"观察者模式",KVB和KVO最明显的使用场景就是在一些界面实时显示很强的地方



## 30. 浅拷贝适合指针,深拷贝适合数据

### tips
1. 浅拷贝,是将原始对象的指针复制到副本中,从而达到原始对象和副本共享引用数据的目的;深拷贝,是复制指针所引用的数据,并将其赋值给副本的实例变量
2. 一般情况下,可以被视为数据容器的指针实例变量往往被深拷贝,而更复杂的实例变量(如代理)则被浅拷贝
3. 实例变量的`set`方法的实现要能够反映出需要使用的赋值类型.如果相应的`set`方法赋值了新的值,那么就应该使用深拷贝这个实例变量
4. 如果实例变量的`set`方法只是简单地将新的值赋给实例变量,而没有复制或保留它,那么就应该浅拷贝这个实例变量

## 31. 谨慎的使用`NSCopying`

### tips
1. 基类没有实现`NSCopying`,那么子类的实现必须复制它所继承的实例变量,以及那些在类中声明的实例变量,最安全的方式是使用`alloc ,init,` 和 `set`方法
2. 类继承了`NSCopying`的行为,并声明了额外的实例变量,那么也需要实现`copyWithZone:`
3. 如果基类使用了或者有可能使用过了`NSCopyObject`,那么必须使用区别于`alloc` 和 `init`函数的情况,用不同的方式处理实例变量

## 32. 使用协议来提供匿名对象

### tips 
1. 采用协议,可以某种程度上实现提供匿名类,具体的对象类型可以淡化成遵从某协议的`id`类型,协议里规定了对象所应该实现的方法
2. 设计程序采用协议,可以减少继承类的复杂性
3. 使用匿名对象来隐藏类型名称(或类名)
4. 如果具体类型不重要,重要的是对象能够响应(定义在协议里的)特定方法,那么可以使用匿名对象来表示

## 33 .使用`category`把类的实现拆分成不同的文件

### tips 
1. 使用类的分类机制,可以把类的实现代码划分成易于管理的小块
2. 应该将视为私有的方法归入`@private`分类中,已隐藏实现细节
3. 把统一各类的实现拆分成多个实现文件的原则是:以同类型或者同业务类型作为参照
